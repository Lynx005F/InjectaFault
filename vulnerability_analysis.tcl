# Copyright 2023 ETH Zurich and University of Bologna.
# Solderpad Hardware License, Version 0.51, see LICENSE for details.
# SPDX-License-Identifier: SHL-0.51
#
# Author: Luca Rufer (lrufer@student.ethz.ch)

# Description: This script uses the fault injection script and the termination
#              monitor to determine the vulnerability of a curcuit to injected
#              faults (bit flips).
#              The script first runs the testbench without an injected error
#              to get a 'golden model' for the execution time and the final
#              internal state.
#              After creating the golden model, the script resets the simulation
#              and starts the testbench again and injects exactly one fault into
#              the simulation. The vulnerability analysis uses the
#              'inject_fault.tcl' script to inject faults. ***It is in the
#              responsibility of the user to configure the settings for the
#              fault injection***.
#              While the simulation is running and an errors is injected, the
#              script checks for the following 5 termination causes using the
#              termination monitor:
#               0) The termination monitor reports that the simulation
#                  terminated without errors and the internal state of the
#                  simulation with fault injections matches the internal state
#                  of the golden model. This case is the 'Correct' case.
#               1) The termination monitor reports that the simulation
#                  terminated without errors, but the internal state of the
#                  is not the same as the golden model. This case is the
#                  'Latent' case, as it terminated corretly, but more errors
#                  migth occur if the programm is allowed to continue running.
#               2) The termination monitor reports a program termination with an
#                  'Incorrect' signal.
#               3) The termination motitor reports an exception, or an invalid
#                  state ('x' or 'z') is detected on any other termination
#                  monitor signal.
#               4) The simulation takes more than 20% longer to finish the
#                  simulation compared to the golden model, indicating that
#                  the simulation is stuck in an infinite (or very long) loop,
#                  or encountered a dead-lock.
#              For every run of the vulnerability analysis the net name,
#              injection time and the termination cause is logged.

# ============ List of variables that may be passed to this script ============
# Any of these variables may not be changed while the vulnerability analysis
# is running, unless noted otherwise. Changing any of the settings during
# runtime may result in undefined behaviour.
# ---------------------------------- General ----------------------------------
# 'verbosity'         : Controls the amount of information printed during script
#                       execution. Possible values are:
#                       0 : No statements at all
#                       1 : Only important initializaion information
#                       2 : Important information and termination status of
#                           the running programm (Recommended). Default
#                       3 : All information that is possible
# 'initial_run_script' : Script (including path) to be sourced before the
#                       execution of the golden model. The script should end
#                       with some form of the 'run' command to start running
#                       the simulation. If this setting is not provided by the
#                       user, or it is an empty string, then this script simply
#                       executes 'run -all'
# 'script_base_path'  : Base path of all the scripts that are sourced here:
#                        - termination_monitor.tcl
#                        - inject_fault.tcl
#                       Default is set to './'
# --------------------------- Vulnerability Analysis --------------------------
# 'initial_seed'      : The initial random seed that is used for the random time
#                       and net selection for the fault injection. The seed is
#                       increased for every injection test round.
#                       The default value is 12345.
# 'max_num_tests'     : Maximum number of tests. Default is 1.
# 'internal_state'    : A list of signals that compose the internal state of
#                       the simulated circuit. This list of signals is used
#                       to check for latent erorrs in simulations with an
#                       injected error. If internal state check is not required,
#                       leave this list empty (default).
# 'earliest_injection_time' : The earliest time the fault may be injected into
#                       the simulation. Default is 0.
# 'latest_injection_time' : The latest time the fault may be injected into
#                       the simulation. If set to 0, this variable will be
#                       set to the execution time of the golden model (Default).
#                       If set to a negative number, this variable will be
#                       changed to the execution time of the golden model plus
#                       this negative number.
# ------------------------ Termination Monitor Signals ------------------------
# 'correct_termination_signal' : Path to the testbench signal that indicates
#                       a correct termination of the simulation. Note that an
#                       'x' or 'z' on this signal is interpreted as an
#                       exception. This parameter MUST be provided by the user
#                       and has no default value.
# 'incorrect_termination_signal' : Path to the testbench signal that indicates
#                       an incorrect termination of the simulation. Note that an
#                       'x' or 'z' on this signal is interpreted as an
#                       exception. If no net is given for this signal, the same
#                       signal as for the exception monitoring is used.
# 'exception_termination_signal' : Path to the testbench signal that indicates
#                       an exception occured in the simulation. Note that an
#                       'x' or 'z' on this signal is also interpreted as an
#                       exception. This parameter MUST be provided by the user
#                       and has no default value.
# --------------------------- Manual Mode Settings ----------------------------
# 'show_waves'        : Show the waves of the nets where faults can be injected
#                       in the default wave window.
#                       0 : Don't log and show the waves (default).
#                       1 : Log and show the waves.
# 'show_fault_in_waves' : Focus the currently active cursor in the currently
#                       active wave window to the time instance where the fault
#                       was injected. This can make debugging faster in manual
#                       mode.
#                       0 : Do not modify cursor and wave windows (default).
#                       1 : Focus the cursor and window time to the fault
#                           injection.
# ------------------------------- Parallel Mode -------------------------------
# 'thread_id'         : Indicates the ID of the current thread. Must be a
#                       non-negative integer smaller than 'num_threads' and must
#                       be unique for every parallel thread. The tread ID
#                       influences the seed that is used for the fault
#                       injection, and the name of the log file. Note that ALL
#                       variables (except for 'thread_id') given to this script
#                       must be equal for ALL parallel threads. The default
#                       value is 0.
# 'num_threads'       : Number of threads that are executing in parallel. The
#                       workload is statically divided amongst all threads. It
#                       is in the responsibility of the user to create
#                       'num_threads' threads that execute the workload.
#                       If the workload is not parallellized and only executed
#                       by a single thread, set 'num_threads' to 1 (default).

##################################
#  Set default parameter values  #
##################################

# General
if {![info exists ::verbosity]}          { set ::verbosity             2 }
if {![info exists ::initial_run_script]} { set ::initial_run_script   "" }
if {![info exists ::script_base_path]}   { set ::script_base_path   "./" }

# Vulnerability Analysis
if {![info exists ::initial_seed]}            { set ::initial_seed        12345 }
if {![info exists ::max_num_tests]}           { set ::max_num_tests           1 }
if {![info exists ::internal_state]}          { set ::internal_state     [list] }
if {![info exists ::earliest_injection_time]} { set ::earliest_injection_time 0 }
if {![info exists ::latest_injection_time]}   { set ::latest_injection_time   0 }

# Termination Monitor Signals
if {![info exists ::correct_termination_signal] || \
    ![info exists ::exception_termination_signal]} {
  echo "\[Vulnerability Analysis\] Error: some mandatory variables were not set."
  quit -code 1
}
if {![info exists ::incorrect_termination_signal]} \
  { set ::incorrect_termination_signal $::exception_termination_signal }

# Manual Mode Settings
if {![info exists ::show_waves         ]} { set ::show_waves          0 }
if {![info exists ::show_fault_in_waves]} { set ::show_fault_in_waves 0 }

# Parallel Mode
if {![info exists ::thread_id   ]} { set ::thread_id   0 }
if {![info exists ::num_threads ]} { set ::num_threads 1 }

######################################
#  Termination monitor return procs  #
######################################

# Post-process the id that was returned from the fault monitor
proc vulnerability_process_termination_id {id} {
  # If terminated correctly, check internal state
  if {$id == 0} {
    # Examine the final state
    set final_state [list]
    foreach net $::internal_state {
      set reg_val [examine $net]
      lappend final_state $reg_val
    }
    # Check for any mismatches compared to the golden model and save the
    # indexes to a list
    set state_mismatches [list]
    for {set i 0} { $i < [llength $::internal_state] } { incr i } {
      if {[lindex $::golden_model_final_state $i] != [lindex $final_state $i]} {
        lappend state_mismatches $i
      }
    }
    # Report if mismatches were found
    if {[llength $state_mismatches] != 0} {
      # Change id if state mismatches were found
      set id 1
      if {$::verbosity >= 2} {
        echo "\[Vulnerability Analysis\] Internal state check failed:"
        foreach i $state_mismatches {
          set final_state_net_val [lindex $final_state $i]
          set golden_model_net_val [lindex $::golden_model_final_state $i]
          echo " - [lindex $::internal_state $i] : expected $golden_model_net_val, got $final_state_net_val."
        }
      }
    } else {
      if {$::verbosity >= 2} {
        echo "\[Vulnerability Analysis\] State check successful."
      }
    }
  }
  return $id
}

# Termination proc for the golden model (called by Termination Monitor)
proc golden_model_termination_report {id} {
  # Check that the golden model finished correctly
  if {$id != 0} {
    if {$::verbosity >= 2} {
      echo "\[Vulnerability Analysis\] Error: Golden Model did not terminate correctly."
    }
    quit -code 1
  } else {
    # Record the execution time of the golden model
    set ::golden_model_execution_time $::now
    if {$::verbosity >= 2} {
      echo "\[Vulnerability Analysis\] Golden model finished within $::golden_model_execution_time ps."
    }
    # Record the final state of the golden model
    set ::golden_model_final_state [list]
    foreach net $::internal_state {
      set reg_val [examine $net]
      lappend ::golden_model_final_state $reg_val
    }
  }
  # Indicate that the monitor was triggered (helps to rule out assertions)
  set ::monitor_triggered 1
}

# Termination proc for the injected simulation (called by Termination Monitor)
proc injection_termination_report {id} {
  # Post-process the id
  set id [vulnerability_process_termination_id $id]

  if {$::verbosity >= 2} {
    echo "\[Vulnerability Analysis\]\
          Flipped $::last_flipped_net at time $::injection_time.\
          Injection terminated with id $id."
  }

  if {$id != 0} {
    incr ::num_tests_failed
  }

  # Log the results
  puts $::vulnerability_log [format "%010u,%01d,%09u,%s" $::seed $id $::injection_time $::last_flipped_net]
  flush $::vulnerability_log

  # Indicate that the monitor was triggered (helps to rule out assertions)
  set ::monitor_triggered 1
}

###################
#  Utility Procs  #
###################

proc get_random_injection_time {} {
  set low $::earliest_injection_time
  set high $::latest_injection_time
  return [expr $low + int(rand() * ($high - $low))]
}

#################################
#  Vulnerability Analysis Round #
#################################

proc vulnerability_analysis_fault_round {} {
  # Restart the simulation
  if {$::verbosity >= 1} {
    echo "\[Vulnerability Analysis\] Reached End of simulation. Restarting..."
  }
  restart -f

  # Reset the RNG
  expr srand($::seed)

  set ::injection_time [get_random_injection_time]
  set ::forced_injection_times [subst {$::injection_time}]

  # Restart the fault injection script
  restart_fault_injection

  # Run the simulation
  while {[eqTime $::now 0]} {run -all}

  # --- Wait for the simulation to finish ---

  # Make sure the stop was triggered by a monitor, otherwise end the script
  # and let the user take over
  if {!$::monitor_triggered} { exit }
  set ::monitor_triggered 0

  incr ::num_tests_finished
  if {$::verbosity >= 2} {
    echo "\[Vulnerability Analysis\] Current vulnerability: \
          $::num_tests_failed/$::num_tests_finished."
  }

  # Manual Mode options
  if {$::show_fault_in_waves} {
    # move the cursor to the injection time
    wave cursor time -time $::injection_time
    # move the wave window to the cursor
    wave cursor see -at 50
  }

  # Increase the seed for the next iteration
  incr ::seed $::num_threads
}

###############################################
#  Main Thread of the Vulnerability Analysis  #
###############################################

# Create the log file
set time_stamp [exec date +%Y%m%d_%H%M%S]
if {$num_threads > 1} {
  set filename "vulnerability_${time_stamp}_${thread_id}.log"
} else {
  set filename "vulnerability_$time_stamp.log"
}
set ::vulnerability_log [open $filename w+]
puts $::vulnerability_log "seed,termination_cause,injection_time,injected_net_name"

# Create the monitor triggered variable
set ::monitor_triggered 0

# === Step 1: Configure the golden model ===

# Configure the monitor settings for the golden model
set ::termination_signal_list [subst { \
  {3 $::exception_termination_signal "Exception" } \
  {2 $::incorrect_termination_signal "Incorrect" } \
  {0 $::correct_termination_signal   "Correct"   }}]

# Report x and z as exception
set ::termination_report_x_as_id 3

# Set the termination callback proc
set ::termination_report_proc golden_model_termination_report

# Setup the monitors
source [subst ${::script_base_path}termination_monitor.tcl]

# Setup manual mode
if {$::show_waves} {
  foreach net $::inject_register_netlist {
    log $net
    add wave $net
  }
  foreach net $::inject_signals_netlist {
    log $net
    add wave $net
  }
}

# Source the run script
if ([string equal $::initial_run_script ""]) {
  run -all
} else {
  source $::initial_run_script
}

# --- wait for the golden model to finish ---

# check that the stop after the run was triggered by a monitor
if {!$::monitor_triggered} { exit }
set ::monitor_triggered 0

########################
#  Find vulnerability  #
########################

set ::num_tests_finished 0
set ::num_tests_failed 0

# update the termination monitor with an appropriate timeout
set timeout_monitor [expr round($::golden_model_execution_time * 1.2)]
lappend ::termination_signal_list [subst {4 $timeout_monitor "Timeout"}]
set ::termination_report_proc injection_termination_report
termination_reset_monitors

# update the latest injection time
if {$::latest_injection_time <= 0} {
  set ::latest_injection_time [expr $::latest_injection_time + $::golden_model_execution_time]
  if {$::verbosity >= 2} {
     echo "\[Vulnerability Analysis\] Set latest injection time to $::latest_injection_time."
  }
}

# Source the fault injection script to start fault injection
# The parameters for the fault injection script have to be set up by the user,
# but some are explicitly set here:
set ::seed [expr $::initial_seed + $::thread_id]
set injection_clock ""
set forced_injection_times [list]
set forced_injection_signals [list]
set ::include_forced_inj_in_stats 1
source [subst ${::script_base_path}inject_fault.tcl]

# Execute the tests
set thread_num_tests [expr ($::max_num_tests / $::num_threads)]
if {$::thread_id < ($::max_num_tests % $::num_threads)} {
  incr thread_num_tests
}
for {set i 0} { $i < $thread_num_tests } { incr i } {
  vulnerability_analysis_fault_round
}

if {$::verbosity >= 1} {
  echo "\[Vulnerability Analysis\] Reached the end of the automatic \
        vulnerability analysis. You can manually run more test by running \
        'vulnerability_analysis_fault_round'."
}
